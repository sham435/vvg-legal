import { Injectable, Logger } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import axios from "axios";
import { YoutubeService } from "../youtube/youtube.service";
import { PrismaService } from "../../common/prisma/prisma.service";

@Injectable()
export class PublishService {
  private readonly logger = new Logger(PublishService.name);
  private readonly facebookToken: string;
  private readonly instagramToken: string;

  constructor(
    private readonly config: ConfigService,
    private readonly youtubeService: YoutubeService,
    private readonly prisma: PrismaService,
  ) {
    this.facebookToken = this.config.get<string>("FACEBOOK_PAGE_TOKEN");
    this.instagramToken = this.config.get<string>("INSTAGRAM_ACCESS_TOKEN");
  }

  /**
   * Check if the YouTube API is successfully connected and authorized.
   */
  async checkYouTubeConnection(): Promise<any> {
    return this.youtubeService.checkConnection();
  }

  /**
   * Upload a video to YouTube using the robust YoutubeService (OAuth).
   */
  async uploadToYouTube(
    videoPath: string,
    title: string,
    description: string,
  ): Promise<any> {
    if (!videoPath) {
      throw new Error("Video path is required for YouTube upload");
    }

    // Create tracking records
    const video = await this.prisma.video.create({
      data: {
        title,
        description,
        localPath: videoPath,
        script: "Generated by pipeline",
        status: "PUBLISHING",
      },
    });

    const log = await this.prisma.publishLog.create({
      data: {
        videoId: video.id,
        platform: "YOUTUBE",
        status: "UPLOADING",
      },
    });

    this.logger.log(`Created Video ${video.id} and PublishLog ${log.id}`);

    try {
      this.logger.log(`Uploading to YouTube via OAuth Service: ${title}`);
      const videoUrl = await this.youtubeService.uploadVideo(
        videoPath,
        title,
        description,
      );

      // Update success
      await this.prisma.publishLog.update({
        where: { id: log.id },
        data: {
          status: "PUBLISHED",
          platformUrl: videoUrl,
          platformVideoId: videoUrl.split("v=")[1],
          publishedAt: new Date(),
        },
      });

      await this.prisma.video.update({
        where: { id: video.id },
        data: { status: "PUBLISHED", videoUrl },
      });

      return videoUrl;
    } catch (error) {
      // Update failure
      await this.prisma.publishLog.update({
        where: { id: log.id },
        data: {
          status: "FAILED",
          errorMessage: error.message,
        },
      });
      await this.prisma.video.update({
        where: { id: video.id },
        data: { status: "FAILED" },
      });
      throw error;
    }
  }

  /**
   * Retry publishing a video by ID
   */
  async publishVideoById(videoId: string): Promise<any> {
    const video = await this.prisma.video.findUnique({
      where: { id: videoId },
    });

    if (!video || !video.localPath) {
      throw new Error(`Video ${videoId} not found or missing local file path`);
    }

    return this.uploadToYouTube(
      video.localPath,
      video.title,
      video.description || "",
    );
  }

  /**
   * Publish video to Facebook Page.
   */
  async publishToFacebook(videoUrl: string, caption: string): Promise<any> {
    if (!this.facebookToken) {
      throw new Error("FACEBOOK_PAGE_TOKEN not configured");
    }
    const response = await axios.post(
      `https://graph.facebook.com/v12.0/me/videos`,
      {
        file_url: videoUrl,
        description: caption,
        access_token: this.facebookToken,
      },
    );
    return response.data;
  }

  /**
   * Publish video to Instagram (via Facebook Graph API).
   */
  async publishToInstagram(videoUrl: string, caption: string): Promise<any> {
    if (!this.instagramToken) {
      throw new Error("INSTAGRAM_ACCESS_TOKEN not configured");
    }
    const response = await axios.post(
      `https://graph.facebook.com/v12.0/instagram_user_id/media`,
      {
        video_url: videoUrl,
        caption,
        access_token: this.instagramToken,
      },
    );
    return response.data;
  }
}
